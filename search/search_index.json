{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bingqilin","text":"<p> A collection of utilities to serve as syntactic ice cream for your FastAPI app </p> <p> </p> <p>Documentation: https://a-huy.github.io/bingqilin/</p> <p>Source Code: https://github.com/a-huy/bingqilin</p>"},{"location":"#features","title":"Features","text":"<p>This package contains some utilities for common actions and resources for your FastAPI app:</p> <ul> <li> <p>Extended Settings Loading - Bingqilin provides additional pieces to enhance Pydantic's <code>BaseSettings</code>:</p> <ul> <li>Add settings sources to enable loading from <code>.yaml</code> files or <code>.ini</code> files</li> <li>Allow the option to add the settings model to the OpenAPI docs (<code>/docs</code>)</li> <li>A base <code>ConfigModel</code> derived from Pydantic's <code>BaseSettings</code> that will allow configuring parts of your FastAPI app and Bingqilin's utilities via settings </li> <li>Provides a <code>SettingsManager</code> class to attach your settings model to allow live reconfiguring</li> </ul> </li> <li> <p>Reconfigurable Contexts - Provide constructs to declare shared connection objects (such as databases and third-party clients) that can be initialized from settings and can be enabled for live reconfiguring.</p> </li> <li> <p>Validation Error Logging - Add an exception handler for <code>RequestValidationError</code> that emits a log.      Useful for troubleshooting routes that support a lot of different types of requests, such as      third-party callback handlers.</p> </li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>This package is intended for use with any recent version of FastAPI (<code>&gt;=0.95.2</code>).</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install bingqilin\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"user-guide/configuration/","title":"Configuration","text":"<p>Creating a settings instance in Bingqilin is a little different:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings().load(_env_file=\".env\", _env_nested_delimiter=\"__\")\n\napp = settings.data.fastapi.create_app()\n</code></pre>"},{"location":"user-guide/configuration/#settingsmanager","title":"SettingsManager","text":"<p>The <code>SettingsManager</code> object is a thin wrapper around your settings model instance that will automatically register a reconfigure handler and update the references to it from other parts of your app if your config changes after a live reload.</p> <p>Why not just initialize an instance of the settings on the module level?</p> <p>You can do this if you know that the settings instance will not change after the initial import/load. Otherwise, all other modules that reference the settings instance would have to reimport it (thereby adding an import statement in the middle of your code) to get the updated values.</p> <p>The <code>load()</code> function for <code>SettingsManager</code> will take whatever keyword arguments are passed into it and use it to initialize the settings model instance:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings().load(_env_file=\".env\", _env_nested_delimiter=\"__\")\n\napp = settings.data.fastapi.create_app()\n</code></pre> <p>If you'd like to disable the registration of a reconfigure handler for your settings, you can pass <code>allow_reconfigure=False</code> into <code>load()</code>.</p>"},{"location":"user-guide/configuration/#configmodel","title":"ConfigModel","text":"<p>Underneath the hood, Bingqilin's <code>ConfigModel</code> is extending a Pydantic settings' <code>BaseSettings</code> object, so working with it should be familiar. However, there are several primary differences:</p> <ul> <li><code>ConfigModel</code> overrides <code>settings_customise_sources()</code> to add a <code>YamlSettingsSource</code> and an <code>IniSettingsSource</code> as the lowest precedences sources.</li> <li>It has a <code>fastapi</code> field you can use to configure initialization behavior when creating your FastAPI app.</li> <li>It has a <code>databases</code> field you can use to define your database connection config. Values for the config mapping must be derived from the <code>DBConfig</code> class.</li> <li>There are boolean fields defined that toggle the various Bingqilin utilities.</li> </ul> <p>Warning</p> <p>The YAML settings source depends on the <code>pyyaml</code> package to load its files. If you attempt to specify a YAML file via the <code>files</code> keyword argument without it installed, a <code>MissingDependencyError</code> will be raised to inform you about the missing package.</p> <p>If your settings model does derive from <code>ConfigModel</code>, the <code>fastapi</code> model value (as an instance of <code>bingqilin.conf.models:FastAPIConfig</code>) provides a convenience function to create your app instance:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings().load(_env_file=\".env\", _env_nested_delimiter=\"__\")\n\napp = settings.data.fastapi.create_app()\n</code></pre>"},{"location":"user-guide/contexts/","title":"LifespanContext objects","text":"<p>Lifespan contexts are a kind of model that you can create declaratively for connections, clients, and other data that you can share across your app. For example:</p> <pre><code>from bingqilin.contexts import (\n    LifespanContext,\n    ContextField,\n    DatabaseField,\n    RedisField,\n    SQLAlchemyField,\n    ThirdPartyField,\n    initializer,\n)\nfrom bingqilin.db.sqlalchemy import SQLAlchemyClient, RedisClientTypes\n\nfrom .clients import MyAPIClientClass\nfrom .config import settings\nfrom .learning import load_models, cleanup_models\nfrom .models import MyAPIConfig, VectorDatabaseClient, VectorDatabaseConfig\n\nclass MyContext(LifespanContext):\n    name = 'my_context'\n\n    postgres: SQLAlchemyClient = SQLAlchemyField(is_default=True)\n    redis: RedisClientTypes = RedisField()\n    vector: VectorDatabaseClient = DatabaseField(\n        config_model=VectorDatabaseConfig,\n        initialize_func=lambda config: VectorDatabaseClient.create_from_config(\n            **config\n        ),\n        config_getter_func=lambda settings: settings.databases.vector\n    )\n\n    my_api_client: MyAPIClientClass = ThirdPartyField(\n        config_model=MyAPIConfig,\n        initialize_func=lambda config: MyAPIClientClass(config),\n        config_getter_func=lambda settings: settings.my_client\n    )\n\n    ml_models: dict = ContextField('ml')\n\n    @initializer('ml_models')\n    @classmethod\n    def initialize_ml_models(cls, init_values):\n        return load_models()\n\n    @terminator('ml_models')\n    @classmethod\n    def terminate_ml_models(cls):\n        cleanup_models()\n\n\ncontext = MyContext(settings)\ncontext.configure(ml_models={'config_1': 42, 'tuning_values': [1, 49, 200]})\n</code></pre> <p>The snippet above is intended to demonstrate everything that context managers have to offer. Defining a lifespan context will require you to provide a couple things:</p> <ul> <li>How to refer to the connection, and what its type is</li> <li>How to initialize the field by either using a convenience <code>ContextField</code> derived class, by specifying an initialization function, or with a <code>@initiator</code> decorated classmethod.</li> </ul>"},{"location":"user-guide/contexts/#defining-a-field-with-contextfield","title":"Defining a field with <code>ContextField</code>","text":"<pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    ml_models: dict = ContextField('ml', is_default=True)\n\ncontext = AppContext(settings.data)\n</code></pre> <p>The default behavior of LifespanContext objects if a model is defined at init time and no initializers are found for the field is to look for a <code>settings_data.{context_name}.{field_name}</code> value, and use that as the config for setting up the field's annotated type. In the example above, since no custom initializers are found, it will look for the <code>ml_models</code> field config in <code>settings.data.app.ml_models</code>.</p>"},{"location":"user-guide/contexts/#namespaces","title":"Namespaces","text":"<p>Within a context, each field belongs to a namespace that will be grouped together. You can specify a particular field to be the default field for that namespace, and the following expressions will return the same field value:</p> <ul> <li><code>context.ml_models</code></li> <li><code>context.get_default('ml')</code></li> </ul> <p>If there is only one namespace defined across all the fields in the context, you don't have to specify a namespace when getting the default field. <code>context.get_default()</code> will still return <code>context.ml_models</code>.</p> <p>Bingqilin provides a couple conveniences for defining fields in common namespaces:</p> <ul> <li><code>DatabaseField()</code> for the <code>databases</code> namespace</li> <li><code>ThirdPartyField()</code> for the <code>third_parties</code> namespace</li> </ul>"},{"location":"user-guide/contexts/#specifying-a-pydantic-model","title":"Specifying a Pydantic Model","text":"<p>When declaring a <code>ContextField</code>, you can pass in a <code>config_model</code> parameter to validate the value of the settings instance to that model if it's not already an instance of the model:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    ml_models: dict = ContextField('ml', config_model=MLModelsConfig)\n\ncontext = AppContext(settings.data)\n</code></pre> <p>This will take the value of <code>settings.data.app.ml_models</code> and attempt to validate it as an <code>MLModelsConfig</code> instance.</p>"},{"location":"user-guide/contexts/#config-getter-functions","title":"Config Getter Functions","text":"<p>Sometimes, your config is located in a different location in your settings instance than what <code>LifespanContext</code> would assume. You can define a <code>config_getter_func</code> parameter for <code>ContextField</code>s that accept a parameter for your settings instance and returns the config for that field:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    ml_models: dict = ContextField(\n        'ml',\n        config_model=MLModelsConfig\n        config_getter_func=lambda settings: settings.other_config_model.ml_models\n    )\n\ncontext = AppContext(settings.data)\n</code></pre> <p>Or, your config might not even come from settings at all:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nML_MODELS_CONFIG = {'the_best_model': 42}\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    ml_models: dict = ContextField(\n        'ml',\n        config_model=MLModelsConfig\n        config_getter_func=lambda settings: ML_MODELS_CONFIG\n    )\n\ncontext = AppContext(settings.data)\n</code></pre>"},{"location":"user-guide/contexts/#initializers","title":"Initializers","text":"<p>You specify logic for intializing a field in two ways:</p>"},{"location":"user-guide/contexts/#the-initialize_func-parameter","title":"The <code>initialize_func</code> Parameter","text":"<pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nfrom .learning import initialize_learning\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nML_MODELS_CONFIG = {'the_best_model': 42}\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    ml_models: dict = ContextField(\n        'ml',\n        config_model=MLModelsConfig\n        config_getter_func=lambda settings: ML_MODELS_CONFIG,\n        initialize_func=lambda config: initialize_learning(config)\n    )\n\ncontext = AppContext(settings.data)\n</code></pre> <p>Functions specified this way must take a parameter for the validated config value.</p>"},{"location":"user-guide/contexts/#the-initializer-decorator","title":"The <code>@initializer</code> Decorator","text":"<pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nfrom .learning import initialize_learning\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nML_MODELS_CONFIG = {'the_best_model': 42}\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    ml_models: dict = ContextField(\n        'ml',\n        config_model=MLModelsConfig\n        config_getter_func=lambda settings: ML_MODELS_CONFIG\n    )\n\n    @initializer('ml_models')\n    def initialize_ml_models(cls, config: MLModelsConfig):\n        return initialize_learning(config)\n\ncontext = AppContext(settings.data)\n</code></pre> <p>Decorated methods MUST be a classmethod. Each initializer must accept a parameter for the validated config value.</p>"},{"location":"user-guide/contexts/#terminators","title":"Terminators","text":"<p>Similar methods and functions can be defined to do any cleanup for fields, by using the <code>terminate_func</code> parameter for <code>ContextField</code>s or the <code>@terminator</code> decorator. These methods do not have to accept any parameters.</p>"},{"location":"user-guide/contexts/#sqlalchemyfield-and-redisfield","title":"<code>SQLAlchemyField</code> and <code>RedisField</code>","text":"<p>Additionally, Bingqilin also provides a couple convenience fields that tie together some SQLAlchemy or Redis utilities you might use together to define database connections:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext, RedisField, SQLAlchemyField\nfrom bingqilin.db.redis import RedisClientTypes\nfrom bingqilin.db.sqlalchemy import SQLAlchemyClient\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nclass DatabasesContext(ContextManager):\n    name = 'databases'\n    postgres: SQLAlchemyClient = SQLAlchemyField(is_default=True)\n    redis: RedisClientTypes = RedisField()\n\ncontext = DatabasesContext(settings.data)\n</code></pre> <p><code>SQLAlchemyField</code> is a proxy call to <code>DatabaseField()</code> with three parameters set: A <code>namespace</code> for <code>databases</code>, <code>SQLAlchemyDBConfig</code> as the <code>config_model</code>, and <code>initialize_func</code> with an inline function to call <code>initialize_client()</code> on the config model instance. the <code>RedisField</code> call does the same for its respective config model (<code>RedisDBConfig</code>).</p>"},{"location":"user-guide/contexts/#databasefields","title":"<code>DatabaseField</code>s","text":"<p>If you have a database connection you'd like to declare, you can just put them under the <code>databases</code> namespace by declaring it as a <code>DatabaseField()</code>. You can override any initializers and config models as well.</p>"},{"location":"user-guide/contexts/#multiple-contexts","title":"Multiple Contexts","text":"<p>You don't have to put everything under one context - if it fits your needs better, you can define multiple contexts if it makes more sense:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext, RedisField, SQLAlchemyField\nfrom bingqilin.db.redis import RedisClientTypes\nfrom bingqilin.db.sqlalchemy import SQLAlchemyClient\n\nfrom .learning import initialize_learning\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nclass DatabasesContext(ContextManager):\n    name = 'databases'\n    postgres: SQLAlchemyClient = SQLAlchemyField(is_default=True)\n    redis: RedisClientTypes = RedisField()\n\nclass LearningContext(LifespanContext):\n    name = 'ai'\n\n    ml_models: dict = ContextField(\n        'ml',\n        config_model=MLModelsConfig\n        config_getter_func=lambda settings: ML_MODELS_CONFIG,\n        initialize_func=lambda config: initialize_learning(config)\n    )\n\ndatabases = DatabasesContext(settings.data)\nlearning_models = LearningContext(settings.data)\n</code></pre>"},{"location":"user-guide/contexts/#disabling-reconfiguration","title":"Disabling Reconfiguration","text":"<p>By default, whenever a lifespan context instance is created, it will automatically add a reconfigure handler. You can disable this by setting the <code>allow_reconfigure</code> class attribute to <code>False</code>:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nfrom .learning import initialize_learning\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nML_MODELS_CONFIG = {'the_best_model': 42}\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    allow_reconfigure = False\n\n    ml_models: dict = ContextField(\n        'ml',\n        config_model=MLModelsConfig\n        config_getter_func=lambda settings: ML_MODELS_CONFIG,\n        initialize_func=lambda config: initialize_learning(config)\n    )\n\ncontext = AppContext(settings.data)\n</code></pre>"},{"location":"user-guide/databases/","title":"Databases","text":"<p>Bingqilin offers a base model class to read and convert database client options into instances that can be accessed via <code>bingqilin.db:get_db_client()</code>.</p>"},{"location":"user-guide/databases/#configuring-a-database-client","title":"Configuring a Database Client","text":"<p>Information for your database clients are declared in the <code>databases</code> field of your config. The field is a mapping that is keyed by the ID or name that you would like to use to retrieve that client in your app.</p> <p>Ex:</p> config.yaml<pre><code>databases:\n    default:\n        type: sqlalchemy\n        engine: postgresql\n        user: user\n        password: testdb123\n        host: postgresserver\n        database: db\n        port: 5432\n    redis:\n        type: redis\n        host: redisserver\n        port: 6379\n        db: 0\n...\n</code></pre> <p>Here, there are two databases configured - An SQLAlchemy client connected to a PostgreSQL server, and a Redis client.</p> <p>Tip</p> <p>If you declare config for a database client under the <code>default</code> key, it will be the client retrieved if no client ID is specified when calling <code>get_db_client()</code>.</p>"},{"location":"user-guide/databases/#custom-database-config-models","title":"Custom Database Config Models","text":"<p>You can also declare your own database config models to use in your <code>ConfigModel</code> and determine how the client object is created:</p> <pre><code>from typing import Literal, Optional\nfrom bingqilin.db.models import DBConfig\n\nfrom database_lib import DatabaseClient\n\n\nclass MyDBConfig(DBConfig):\n    type: Literal[\"my_database\"]\n    name: str\n    user: Optional[str]\n    password: Optional[str]\n    port: int = 10101\n\n    def initialize_client(self):\n        return DatabaseClient(\n            host=self.host, \n            port=self.port, \n            username=self.user, \n            password=self.password, \n            name=self.name\n        )\n</code></pre> <ol> <li>Custom database config models must derive from <code>DBConfig</code>. This allows the model to be registered and have their <code>initialize_client()</code> method called after validation.</li> <li>DB config models must define a <code>type</code> class attributed annotated with a <code>Literal</code> string. This is used when loading config so that the validator knows which model to validate against.</li> <li>DB config models must implement an <code>initialize_client()</code> method that returns a handle to the configured database, ORM, client pool, etc.</li> </ol> <p>Note</p> <p>The base <code>DBConfig</code> model already has the <code>host</code> and <code>port</code> fields for use. Under the hood, it's really just a Pydantic <code>BaseModel</code>, so you can override these if you'd like.</p> <p>Then declare a database connection client in your config:</p> config.yaml<pre><code>databases:\n    default:\n        type: my_database\n...\n</code></pre> <p>Finally, retrieve the client in your app and use it:</p> <pre><code>from bingqilin.db import get_db_client\nfrom database_lib import DatabaseClient\nfrom fastapi import APIRouter\nfrom uuid import UUID\n\nfrom .models import ObjectOrm, ObjectOut\n\nrouter = APIRouter()\n\n@router.get('/object/{object_id}')\nasync def get_object(object_id: UUID):\n    my_database_client: DatabaseClient = get_db_client()\n    with my_database_client.session() as session:\n        return ObjectOut(**session.get(ObjectOrm, object_id))\n</code></pre>"},{"location":"user-guide/databases/#sqlalchemy","title":"SQLAlchemy","text":"<p>Bingqilin provides an SQLAlchemy client class you can declare in config with the type <code>sqlalchemy</code>. This will return a <code>bingqilin.db.sqlalchemy:SQLAlchemyClient</code> instance after validation. The module also provides a couple convenience functions (<code>get_sync_db()</code> and <code>get_async_db()</code>) to inject a session object as a dependency:</p> <pre><code>from bingqilin.db import get_sync_db\nfrom fastapi import APIRouter, Depends\nfrom sqlalchemy.orm import Session\nfrom uuid import UUID\n\nfrom .models import ObjectOrm, ObjectOut\n\nrouter = APIRouter()\n\n@router.get('/object/{object_id}')\nasync def get_object(\n    object_id: UUID, \n    db: Session = Depends(get_sync_db(\"the_other_db_client\"))\n):\n    return ObjectOut(\n        **db.query(ObjectOrm).filter(ObjectOrm.id==object_id).one()\n    )\n</code></pre>"},{"location":"user-guide/setup/","title":"Setup","text":"<p>Bingqilin exposes a <code>setup_utils()</code> function that takes a <code>ConfigModel</code> settings instance and your FastAPI app instance to add any configured features.</p> <pre><code>from bingqilin import setup_utils\n\nfrom .settings import settings\n\napp = FastAPI()\nsetup_utils(app, settings.data)\n</code></pre> <p>You can pass in keyword arguments that override the values from your settings data, or you can forgo the <code>setup_utils()</code> function call completely and enable whatever utilities you'd like.</p> <p><code>setup_utils()</code> does the following things:</p> <ul> <li>Adds an exception handler to log validation errors</li> <li>Adds the route operation to handle reconfigures</li> <li>Adds the <code>ConfigModel</code> instance to the OpenAPI spec</li> </ul> <p>In the example above, <code>settings</code> is an instance of <code>bingqilin.conf:SettingsManager</code>, which you can learn more about here.</p>"}]}