{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bingqilin","text":"<p> A collection of utilities to serve as syntactic ice cream for your FastAPI app </p> <p> </p> <p>Documentation: https://a-huy.github.io/bingqilin/  Source Code: https://github.com/a-huy/bingqilin</p>"},{"location":"#features","title":"Features","text":"<p>This package contains some utilities for common actions and resources for your FastAPI app:</p> <ul> <li>Extended Settings Loading - Bingqilin provides additional pieces to enhance Pydantic's <code>BaseSettings</code>:</li> <li>Add settings sources to enable loading from <code>.yaml</code> files or <code>.ini</code> files</li> <li>Allow the option to add the settings model to the OpenAPI docs (<code>/docs</code>)</li> <li>A base <code>ConfigModel</code> derived from Pydantic's <code>BaseSettings</code> that will allow configuring parts of your FastAPI app and Bingqilin's utilities via settings</li> <li> <p>Provides a <code>SettingsManager</code> class to attach your settings model to allow live reconfiguring</p> </li> <li> <p>Reconfigurable Contexts - Provide constructs to declare shared connection objects (such as databases and third-party clients) that can be initialized from settings and can be enabled for live reconfiguring.</p> </li> <li> <p>Validation Error Logging - Add an exception handler for <code>RequestValidationError</code> that emits a log.     Useful for troubleshooting routes that support a lot of different types of requests, such as     third-party callback handlers.</p> </li> <li> <p>Commands Framework (on top of Typer) - Gives a basic framework to easily add management commands and make them discoverable / usable with the <code>bingqilin</code> command.</p> </li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>This package is intended for use with any recent version of FastAPI (<code>&gt;=0.95.2</code>).</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install bingqilin\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"extras/aws/","title":"ARN Types","text":"<p>Bingqilin provides an ARN Pydantic type that you can use for validation:</p> <p><pre><code>from pydantic import BaseModel\nfrom bingqilin.lib.aws.types import ARN\n\nclass MyModel(BaseModel):\n    some_resource: ARN\n\nmodel = MyModel(\n    some_resource=\"arn:aws:ssm:us-west-2:123456789012:parameter/some_param\"\n)\n\n# some_resource=&lt;bingqilin.extras.aws.conf.types.ARN object at 0x102d44610&gt;\n</code></pre> </p>"},{"location":"extras/aws/#additional-settings-sources","title":"Additional Settings Sources","text":"<p>This extras module provides two settings sources that you can use to grab values from commonly used AWS services:</p> <p>Warning</p> <p>These settings sources require the <code>boto3</code> package.</p>"},{"location":"extras/aws/#aws-systems-manager-parameters-storage","title":"AWS Systems Manager Parameters Storage","text":"<p>To draw values from the SSM parameter store when loading your settings, you'll have to do two things:</p> <ol> <li>Add an instance of <code>AWSSystemsManagerParamsSource</code> to your return list in <code>settings_customise_sources()</code></li> <li>Initialize each model field to an instance of <code>SSMParameterField</code></li> </ol> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.extras.aws.conf.sources import AWSSystemsManagerParamsSource\nfrom bingqilin.extras.aws.conf.types import SSMParameterField\n\nclass AppConfigModel(ConfigModel):\n    test_ssm_field: str = SSMParameterField()\n\n    @classmethod\n    def settings_customise_sources(\n        cls, settings_cls: type[BaseSettings], *args, **kwargs\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        sources = list(\n            ConfigModel.settings_customise_sources(cls, *args, **kwargs)\n        )\n        sources.append(AWSSystemsManagerParamsSource(settings_cls))\n        return tuple(sources)\n\nclass AppSettings(SettingsManager):\n    data: AppConfigModel\n\nsettings = AppSettings()\nsettings.load()\n</code></pre> <p>By default, this will tell the <code>boto</code> client to use the default AWS credentials. For the parameter retrieval, it will default to using the field name in an environment variable format (UPPER_SNAKE_CASE).</p> <p>Why do I need to use an instance of <code>SSMParameterField</code> for every parameter I want to load?</p> <p>Because retrieving a parameter from the Systems Manager requires an external HTTP call, this is done to minimize the amount of network calls made.</p> <p>There are a couple changes to the behavior that you can do:</p>"},{"location":"extras/aws/#passing-in-credentials","title":"Passing in credentials","text":"<p>You can specify a region, access key ID, and a secret access key as config for the settings model to initialize the settings source with those credentials:</p> <pre><code>class AppConfigModel(ConfigModel):\n\n    model_config = SettingsConfigDict(\n        aws_region='us-west-1',\n        aws_access_key_id='a_key_id',\n        aws_secret_access_key='totally_secret_key'\n    )\n</code></pre> <pre><code>class AppConfigModel(ConfigModel):\n    test_ssm_field: str = SSMParameterField()\n\n    @classmethod\n    def settings_customise_sources(\n        cls, settings_cls: type[BaseSettings], *args, **kwargs\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        sources = list(\n            ConfigModel.settings_customise_sources(cls, *args, **kwargs)\n        )\n        sources.append(\n            AWSSystemsManagerParamsSource(\n                settings_cls, \n                region='us-west-1', \n                access_key_id='a_key_id', \n                secret_access_key='totally_secret_key'\n            )\n        )\n        return tuple(sources)\n</code></pre>"},{"location":"extras/aws/#specify-an-arn-for-an-ssm-param-field","title":"Specify an ARN for an SSM param field","text":"<pre><code>class AppConfigModel(ConfigModel):\n    test_ssm_field: str = SSMParameterField(\n        arn=\"arn:aws:ssm:us-west-2:123456789012:parameter/some_param\"\n    )\n</code></pre>"},{"location":"extras/aws/#use-the-field-name-exactly-as-is-for-parameter-retrieval","title":"Use the field name exactly as-is for parameter retrieval","text":"<pre><code>class AppConfigModel(ConfigModel):\n    test_ssm_field: str = SSMParameterField(\n        env_var_format=False\n    )\n</code></pre> <p>This will use the name <code>test_ssm_field</code> when requesting the parameter instead of <code>TEST_SSM_FIELD</code>.</p>"},{"location":"extras/aws/#aws-secrets-manager","title":"AWS Secrets Manager","text":"<p>Using this settings source is almost identical to <code>AWSSystemsManagerParamsSource</code>, but using the respective settings source and field objects for the Secrets Manager:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.extras.aws.conf.sources import AWSSecretsManagerSource\nfrom bingqilin.extras.aws.conf.types import SecretsManagerField\n\nclass AppConfigModel(ConfigModel):\n    test_secret_field: str = SecretsManagerField()\n\n    @classmethod\n    def settings_customise_sources(\n        cls, settings_cls: type[BaseSettings], *args, **kwargs\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        sources = list(\n            ConfigModel.settings_customise_sources(cls, *args, **kwargs)\n        )\n        sources.append(AWSSecretsManagerSource(settings_cls))\n        return tuple(sources)\n\nclass AppSettings(SettingsManager):\n    data: AppConfigModel\n\nsettings = AppSettings()\nsettings.load()\n</code></pre> <p>The same support for specifying AWS credentials and also using an ARN will work for the secrets manager settings source/field.</p>"},{"location":"extras/aws/#passing-in-a-secret-name","title":"Passing in a secret name","text":"<p>Additionally, you can specify a <code>secret_name</code> to retrieve the secret value:</p> <pre><code>class AppConfigModel(ConfigModel):\n    test_secret_field: str = SecretsManagerField(\n        secret_name='test/a-secret-name'\n    )\n</code></pre>"},{"location":"user-guide/commands/","title":"Management commands and scripts","text":"<p>Bingqilin provides a basic commands framework to run one-off scripts or do any offline work that includes your app and settings contexts.</p>"},{"location":"user-guide/commands/#setup","title":"Setup","text":"<p>The base <code>ConfigModel</code> class has the following fields for management:</p> <ul> <li><code>management_settings</code>: This is a string that represents a Python path to the module where you have a <code>SettingsManager</code> instantiated (e.g. <code>main:settings</code>)</li> <li><code>management_additional_commands</code>: This is a list of strings that represent Python paths to additional modules containing user-defined commands. Module paths specified here will allow for command discovery and usage.</li> </ul> <p>None of the management settings are required. However, many of the Bingqilin core commands (and most likely some of your own) will depend on a custom app-specific settings manager to have access to additional config values.</p>"},{"location":"user-guide/commands/#adding-new-commands","title":"Adding new commands","text":""},{"location":"user-guide/commands/#create-a-new-commands-module-and-add-make-it-discoverable","title":"Create a new commands module and add make it discoverable","text":"<p>For example, let's assume that you're adding a simple command that dumps the contents of your app settings under a <code>scripts/</code> module called <code>dump_settings.py</code>:</p> <pre><code>\ud83d\udce6 project_root\n\u2502   \ud83d\udcdc __init__.py\n\u2502   \ud83d\udcdc app.py\n\u2502   \ud83d\udcdc contexts.py\n\u2514\u2500\u2500 \ud83d\udcc2 scripts\n    \u2502    \ud83d\udcdc __init__.py\n    \u2502    \ud83d\udcdc dump_settings.py\n</code></pre> <p>Then, you register the scripts module in your settings under <code>management_additional_commands</code> with a group name:</p> .env<pre><code>MANAGEMENT_SETTINGS=\"contexts:settings\"\nMANAGEMENT_ADDITIONAL_COMMANDS='[[\"scripts\", \"scripts\"]]'\n</code></pre> <p>Specifying a group name is optional, as it will default to <code>app</code>.</p>"},{"location":"user-guide/commands/#create-the-dump_settings-command","title":"Create the dump_settings command","text":"<p>At their core, Bingqilin commands are just a thin wrapper around typer commands. However, there are a few rules for creating a Bingqilin command:</p> <ol> <li>Each command must have a class named <code>Command</code> that inherits from <code>BaseCommand</code> (this is a design choice taken from django)</li> <li>The <code>Command</code> class must implement a method called <code>handle()</code>. This is normally the command function that you would implement with typer, so all the args and kwargs annotations will work here.</li> </ol> <p>Here's an implementation for our example command:</p> dump_settings.py<pre><code>from rich import print_json\nfrom typer import Option\nfrom typing import Optional\nfrom typing_extensions import Annotated\nfrom bingqilin.management import BaseCommand\nfrom contexts import settings\n\nclass Command(BaseCommand):\n    # Name will normally be set to the name of the command file.\n    # Set this attribute to override it.\n    name: Optional[str] = \"dump_settings\"\n    # Displays a help message when the `--help` option is specified.\n    help: Optional[str] = \"Print the current values of your settings \"\n                          \"to the console.\"\n    # Adds a short text to the end of your help message of your command.\n    epilog: Optional[str] = \"This is an example command!\"\n    short_help: Optional[str] = \"Dump current settings\"\n    # Prevents this command from being publicized when the `--help` option \n    # is used and available commands are listed.\n    hidden: bool = False\n    # Marks the command as deprecated.\n    deprecated: bool = False\n    # You can specify a custom section that this command will be displayed\n    # under when available commands are listed.\n    rich_help_panel: Optional[str] = None\n    # Requires the app to set non-empty and valid `management_settings` Python \n    # path in order to invoke this command. This means that the command depends\n    # on an app-specific settings manager to be defined.\n    require_app_config = True\n\n    def handle(\n        self, \n        pretty: Annotated[\n            bool,\n            Option(\n                help=\"Pretty print the config values JSON object. \"\n                     \"Defaults to True.\"\n            ),\n        ] = True\n    ):\n        settings_json = settings.data.model_dump_json()\n        print_func = print_json if pretty else print\n        print_func(settings_json)\n</code></pre>"},{"location":"user-guide/commands/#invoke-the-new-command","title":"Invoke the new command","text":"<p>Now, you can discover the new command by running the <code>bingqilin</code> command:</p> <pre><code>bingqilin --help\n\n Usage: bingqilin [OPTIONS] COMMAND [ARGS]...                                   \n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --loglevel                  TEXT  [default: None]                            \u2502\n\u2502 --install-completion              Install completion for the current shell.  \u2502\n\u2502 --show-completion                 Show completion for the current shell, to  \u2502\n\u2502                                   copy it or customize the installation.     \u2502\n\u2502 --help                            Show this message and exit.                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 core                                                                         \u2502\n\u2502 scripts                                                                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>And running the <code>scripts</code> subcommand with the <code>--help</code> option will give:</p> <pre><code>bingqilin scripts --help\n\n Usage: bingqilin scripts [OPTIONS] COMMAND [ARGS]...                           \n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 dump_settings   Dump current settings                                        \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Finally, we run the newly written command:</p> <pre><code>bingqilin scripts dump_settings\n{\n  \"debug\": true,\n  \"loglevel\": 20,\n  ...\n  \"fastapi\": {\n    \"title\": \"FastAPI\",\n    \"summary\": null,\n    \"description\": \"\",\n    \"version\": \"0.1.0\",\n    ...\n  }\n}\n</code></pre>"},{"location":"user-guide/commands/#core-commands","title":"Core commands","text":"<p>Bingqilin has the following builtin commands under the <code>core</code> group:</p>"},{"location":"user-guide/commands/#shell","title":"<code>shell</code>","text":"<p>This opens up an interactive Python shell and has support for you to specify multiple initialization scripts (on top of using <code>PYTHONSTARTUP</code> and <code>pythonrc.py</code>). By default, it will attempt to use any augmented shell you have installed (<code>ipython</code> or <code>bpython</code>) before defaulting to a basic Python interpreter.</p>"},{"location":"user-guide/configuration/","title":"Configuration","text":"<p>Creating a settings instance in Bingqilin is a little different:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings().load(_env_file=\".env\", _env_nested_delimiter=\"__\")\n\napp = settings.data.fastapi.create_app()\n</code></pre>"},{"location":"user-guide/configuration/#settingsmanager","title":"SettingsManager","text":"<p>The <code>SettingsManager</code> object is a thin wrapper around your settings model instance that will automatically register a reconfigure handler and update the references to it from other parts of your app if your config changes after a live reload.</p> <p>Why not just initialize an instance of the settings on the module level?</p> <p>You can do this if you know that the settings instance will not change after the initial import/load. Otherwise, all other modules that reference the settings instance would have to reimport it (thereby adding an import statement in the middle of your code) to get the updated values.</p> <p>The <code>load()</code> function for <code>SettingsManager</code> will take whatever keyword arguments are passed into it and use it to initialize the settings model instance:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings().load(_env_file=\".env\", _env_nested_delimiter=\"__\")\n\napp = settings.data.fastapi.create_app()\n</code></pre> <p>If you'd like to disable the registration of a reconfigure handler for your settings, you can pass <code>allow_reconfigure=False</code> into <code>load()</code>.</p>"},{"location":"user-guide/configuration/#configmodel","title":"ConfigModel","text":"<p>Underneath the hood, Bingqilin's <code>ConfigModel</code> is extending a Pydantic settings' <code>BaseSettings</code> object, so working with it should be familiar. However, there are several primary differences:</p> <ul> <li><code>ConfigModel</code> overrides <code>settings_customise_sources()</code> to add a <code>YamlSettingsSource</code> and an <code>IniSettingsSource</code> as the lowest precedences sources.</li> <li>It has a <code>fastapi</code> field you can use to configure initialization behavior when creating your FastAPI app.</li> <li>It has a <code>databases</code> field you can use to define your database connection config. Values for the config mapping must be derived from the <code>DBConfig</code> class.</li> <li>There are boolean fields defined that toggle the various Bingqilin utilities.</li> </ul> <p>Warning</p> <p>The YAML settings source depends on the <code>pyyaml</code> package to load its files. If you attempt to specify a YAML file via the <code>files</code> keyword argument without it installed, a <code>MissingDependencyError</code> will be raised to inform you about the missing package.</p> <p>If your settings model does derive from <code>ConfigModel</code>, the <code>fastapi</code> model value (as an instance of <code>bingqilin.conf.models:FastAPIConfig</code>) provides a convenience function to create your app instance:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings().load(_env_file=\".env\", _env_nested_delimiter=\"__\")\n\napp = settings.data.fastapi.create_app()\n</code></pre>"},{"location":"user-guide/contexts/","title":"LifespanContext objects","text":"<p>Lifespan contexts are a kind of model that you can create declaratively for connections, clients, and other data that you can share across your app. For example:</p> <pre><code>from bingqilin.contexts import (\n    LifespanContext,\n    ContextField,\n    DatabaseField,\n    RedisField,\n    SQLAlchemyField,\n    ThirdPartyField,\n    initializer,\n)\nfrom bingqilin.db.sqlalchemy import SQLAlchemyClient, RedisClientTypes\n\nfrom .clients import MyAPIClientClass\nfrom .config import settings\nfrom .learning import load_models, cleanup_models\nfrom .models import MyAPIConfig, VectorDatabaseClient, VectorDatabaseConfig\n\nclass MyContext(LifespanContext):\n    name = 'my_context'\n\n    postgres: SQLAlchemyClient = SQLAlchemyField(is_default=True)\n    redis: RedisClientTypes = RedisField()\n    vector: VectorDatabaseClient = DatabaseField(\n        config_model=VectorDatabaseConfig,\n        initialize_func=lambda config: VectorDatabaseClient.create_from_config(\n            **config\n        ),\n        config_getter_func=lambda settings: settings.databases.vector\n    )\n\n    my_api_client: MyAPIClientClass = ThirdPartyField(\n        config_model=MyAPIConfig,\n        initialize_func=lambda config: MyAPIClientClass(config),\n        config_getter_func=lambda settings: settings.my_client\n    )\n\n    ml_models: dict = ContextField('ml')\n\n    @initializer('ml_models')\n    @classmethod\n    def initialize_ml_models(cls, init_values):\n        return load_models()\n\n    @terminator('ml_models')\n    @classmethod\n    def terminate_ml_models(cls):\n        cleanup_models()\n\n\ncontext = MyContext(settings)\ncontext.configure(ml_models={'config_1': 42, 'tuning_values': [1, 49, 200]})\n</code></pre> <p>The snippet above is intended to demonstrate everything that context managers have to offer. Defining a lifespan context will require you to provide a couple things:</p> <ul> <li>How to refer to the connection, and what its type is</li> <li>How to initialize the field by either using a convenience <code>ContextField</code> derived class, by specifying an initialization function, or with a <code>@initiator</code> decorated classmethod.</li> </ul>"},{"location":"user-guide/contexts/#defining-a-field-with-contextfield","title":"Defining a field with <code>ContextField</code>","text":"<pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    ml_models: dict = ContextField('ml', is_default=True)\n\ncontext = AppContext(settings.data)\n</code></pre> <p>The default behavior of LifespanContext objects if a model is defined at init time and no initializers are found for the field is to look for a <code>settings_data.{context_name}.{field_name}</code> value, and use that as the config for setting up the field's annotated type. In the example above, since no custom initializers are found, it will look for the <code>ml_models</code> field config in <code>settings.data.app.ml_models</code>.</p>"},{"location":"user-guide/contexts/#namespaces","title":"Namespaces","text":"<p>Within a context, each field belongs to a namespace that will be grouped together. You can specify a particular field to be the default field for that namespace, and the following expressions will return the same field value:</p> <ul> <li><code>context.ml_models</code></li> <li><code>context.get_default('ml')</code></li> </ul> <p>If there is only one namespace defined across all the fields in the context, you don't have to specify a namespace when getting the default field. <code>context.get_default()</code> will still return <code>context.ml_models</code>.</p> <p>Bingqilin provides a couple conveniences for defining fields in common namespaces:</p> <ul> <li><code>DatabaseField()</code> for the <code>databases</code> namespace</li> <li><code>ThirdPartyField()</code> for the <code>third_parties</code> namespace</li> </ul>"},{"location":"user-guide/contexts/#specifying-a-pydantic-model","title":"Specifying a Pydantic Model","text":"<p>When declaring a <code>ContextField</code>, you can pass in a <code>config_model</code> parameter to validate the value of the settings instance to that model if it's not already an instance of the model:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    ml_models: dict = ContextField('ml', config_model=MLModelsConfig)\n\ncontext = AppContext(settings.data)\n</code></pre> <p>This will take the value of <code>settings.data.app.ml_models</code> and attempt to validate it as an <code>MLModelsConfig</code> instance.</p>"},{"location":"user-guide/contexts/#config-getter-functions","title":"Config Getter Functions","text":"<p>Sometimes, your config is located in a different location in your settings instance than what <code>LifespanContext</code> would assume. You can define a <code>config_getter_func</code> parameter for <code>ContextField</code>s that accept a parameter for your settings instance and returns the config for that field:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    ml_models: dict = ContextField(\n        'ml',\n        config_model=MLModelsConfig\n        config_getter_func=lambda settings: settings.other_config_model.ml_models\n    )\n\ncontext = AppContext(settings.data)\n</code></pre> <p>Or, your config might not even come from settings at all:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nML_MODELS_CONFIG = {'the_best_model': 42}\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    ml_models: dict = ContextField(\n        'ml',\n        config_model=MLModelsConfig\n        config_getter_func=lambda settings: ML_MODELS_CONFIG\n    )\n\ncontext = AppContext(settings.data)\n</code></pre>"},{"location":"user-guide/contexts/#initializers","title":"Initializers","text":"<p>You specify logic for intializing a field in two ways:</p>"},{"location":"user-guide/contexts/#the-initialize_func-parameter","title":"The <code>initialize_func</code> Parameter","text":"<pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nfrom .learning import initialize_learning\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nML_MODELS_CONFIG = {'the_best_model': 42}\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    ml_models: dict = ContextField(\n        'ml',\n        config_model=MLModelsConfig\n        config_getter_func=lambda settings: ML_MODELS_CONFIG,\n        initialize_func=lambda config: initialize_learning(config)\n    )\n\ncontext = AppContext(settings.data)\n</code></pre> <p>Functions specified this way must take a parameter for the validated config value.</p>"},{"location":"user-guide/contexts/#the-initializer-decorator","title":"The <code>@initializer</code> Decorator","text":"<pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nfrom .learning import initialize_learning\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nML_MODELS_CONFIG = {'the_best_model': 42}\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    ml_models: dict = ContextField(\n        'ml',\n        config_model=MLModelsConfig\n        config_getter_func=lambda settings: ML_MODELS_CONFIG\n    )\n\n    @initializer('ml_models')\n    def initialize_ml_models(cls, config: MLModelsConfig):\n        return initialize_learning(config)\n\ncontext = AppContext(settings.data)\n</code></pre> <p>Decorated methods MUST be a classmethod. Each initializer must accept a parameter for the validated config value.</p>"},{"location":"user-guide/contexts/#terminators","title":"Terminators","text":"<p>Similar methods and functions can be defined to do any cleanup for fields, by using the <code>terminate_func</code> parameter for <code>ContextField</code>s or the <code>@terminator</code> decorator. These methods do not have to accept any parameters.</p>"},{"location":"user-guide/contexts/#sqlalchemyfield-and-redisfield","title":"<code>SQLAlchemyField</code> and <code>RedisField</code>","text":"<p>Additionally, Bingqilin also provides a couple convenience fields that tie together some SQLAlchemy or Redis utilities you might use together to define database connections:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext, RedisField, SQLAlchemyField\nfrom bingqilin.db.redis import RedisClientTypes\nfrom bingqilin.db.sqlalchemy import SQLAlchemyClient\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nclass DatabasesContext(ContextManager):\n    name = 'databases'\n    postgres: SQLAlchemyClient = SQLAlchemyField(is_default=True)\n    redis: RedisClientTypes = RedisField()\n\ncontext = DatabasesContext(settings.data)\n</code></pre> <p><code>SQLAlchemyField</code> is a proxy call to <code>DatabaseField()</code> with three parameters set: A <code>namespace</code> for <code>databases</code>, <code>SQLAlchemyDBConfig</code> as the <code>config_model</code>, and <code>initialize_func</code> with an inline function to call <code>initialize_client()</code> on the config model instance. the <code>RedisField</code> call does the same for its respective config model (<code>RedisDBConfig</code>).</p>"},{"location":"user-guide/contexts/#databasefields","title":"<code>DatabaseField</code>s","text":"<p>If you have a database connection you'd like to declare, you can just put them under the <code>databases</code> namespace by declaring it as a <code>DatabaseField()</code>. You can override any initializers and config models as well.</p>"},{"location":"user-guide/contexts/#multiple-contexts","title":"Multiple Contexts","text":"<p>You don't have to put everything under one context - if it fits your needs better, you can define multiple contexts if it makes more sense:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext, RedisField, SQLAlchemyField\nfrom bingqilin.db.redis import RedisClientTypes\nfrom bingqilin.db.sqlalchemy import SQLAlchemyClient\n\nfrom .learning import initialize_learning\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nclass DatabasesContext(ContextManager):\n    name = 'databases'\n    postgres: SQLAlchemyClient = SQLAlchemyField(is_default=True)\n    redis: RedisClientTypes = RedisField()\n\nclass LearningContext(LifespanContext):\n    name = 'ai'\n\n    ml_models: dict = ContextField(\n        'ml',\n        config_model=MLModelsConfig\n        config_getter_func=lambda settings: ML_MODELS_CONFIG,\n        initialize_func=lambda config: initialize_learning(config)\n    )\n\ndatabases = DatabasesContext(settings.data)\nlearning_models = LearningContext(settings.data)\n</code></pre>"},{"location":"user-guide/contexts/#disabling-reconfiguration","title":"Disabling Reconfiguration","text":"<p>By default, whenever a lifespan context instance is created, it will automatically add a reconfigure handler. You can disable this by setting the <code>allow_reconfigure</code> class attribute to <code>False</code>:</p> <pre><code>from bingqilin.conf import SettingsManager\nfrom bingqilin.conf.models import ConfigModel\nfrom bingqilin.contexts import LifespanContext\n\nfrom .learning import initialize_learning\nfrom .models import MLModelsConfig\n\nclass AppSettings(SettingsManager):\n    data: ConfigModel\n\nsettings = AppSettings()\n\nML_MODELS_CONFIG = {'the_best_model': 42}\n\nclass AppContext(LifespanContext):\n    name = 'app'\n\n    allow_reconfigure = False\n\n    ml_models: dict = ContextField(\n        'ml',\n        config_model=MLModelsConfig\n        config_getter_func=lambda settings: ML_MODELS_CONFIG,\n        initialize_func=lambda config: initialize_learning(config)\n    )\n\ncontext = AppContext(settings.data)\n</code></pre>"},{"location":"user-guide/databases/","title":"Databases","text":"<p>Bingqilin offers a base model class to read and convert database client options into instances that can be accessed via <code>bingqilin.db:get_db_client()</code>.</p>"},{"location":"user-guide/databases/#configuring-a-database-client","title":"Configuring a Database Client","text":"<p>Information for your database clients are declared in the <code>databases</code> field of your config. The field is a mapping that is keyed by the ID or name that you would like to use to retrieve that client in your app.</p> <p>Ex:</p> config.yaml<pre><code>databases:\n    default:\n        type: sqlalchemy\n        engine: postgresql\n        user: user\n        password: testdb123\n        host: postgresserver\n        database: db\n        port: 5432\n    redis:\n        type: redis\n        host: redisserver\n        port: 6379\n        db: 0\n...\n</code></pre> <p>Here, there are two databases configured - An SQLAlchemy client connected to a PostgreSQL server, and a Redis client.</p> <p>Tip</p> <p>If you declare config for a database client under the <code>default</code> key, it will be the client retrieved if no client ID is specified when calling <code>get_db_client()</code>.</p>"},{"location":"user-guide/databases/#custom-database-config-models","title":"Custom Database Config Models","text":"<p>You can also declare your own database config models to use in your <code>ConfigModel</code> and determine how the client object is created:</p> <pre><code>from typing import Literal, Optional\nfrom bingqilin.db.models import DBConfig\n\nfrom database_lib import DatabaseClient\n\n\nclass MyDBConfig(DBConfig):\n    type: Literal[\"my_database\"]\n    name: str\n    user: Optional[str]\n    password: Optional[str]\n    port: int = 10101\n\n    def initialize_client(self):\n        return DatabaseClient(\n            host=self.host, \n            port=self.port, \n            username=self.user, \n            password=self.password, \n            name=self.name\n        )\n</code></pre> <ol> <li>Custom database config models must derive from <code>DBConfig</code>. This allows the model to be registered and have their <code>initialize_client()</code> method called after validation.</li> <li>DB config models must define a <code>type</code> class attributed annotated with a <code>Literal</code> string. This is used when loading config so that the validator knows which model to validate against.</li> <li>DB config models must implement an <code>initialize_client()</code> method that returns a handle to the configured database, ORM, client pool, etc.</li> </ol> <p>Note</p> <p>The base <code>DBConfig</code> model already has the <code>host</code> and <code>port</code> fields for use. Under the hood, it's really just a Pydantic <code>BaseModel</code>, so you can override these if you'd like.</p> <p>Then declare a database connection client in your config:</p> config.yaml<pre><code>databases:\n    default:\n        type: my_database\n...\n</code></pre> <p>Finally, retrieve the client in your app and use it:</p> <pre><code>from bingqilin.db import get_db_client\nfrom database_lib import DatabaseClient\nfrom fastapi import APIRouter\nfrom uuid import UUID\n\nfrom .models import ObjectOrm, ObjectOut\n\nrouter = APIRouter()\n\n@router.get('/object/{object_id}')\nasync def get_object(object_id: UUID):\n    my_database_client: DatabaseClient = get_db_client()\n    with my_database_client.session() as session:\n        return ObjectOut(**session.get(ObjectOrm, object_id))\n</code></pre>"},{"location":"user-guide/databases/#sqlalchemy","title":"SQLAlchemy","text":"<p>Bingqilin provides an SQLAlchemy client class you can declare in config with the type <code>sqlalchemy</code>. This will return a <code>bingqilin.db.sqlalchemy:SQLAlchemyClient</code> instance after validation. The module also provides a couple convenience functions (<code>get_sync_db()</code> and <code>get_async_db()</code>) to inject a session object as a dependency:</p> <pre><code>from bingqilin.db import get_sync_db\nfrom fastapi import APIRouter, Depends\nfrom sqlalchemy.orm import Session\nfrom uuid import UUID\n\nfrom .models import ObjectOrm, ObjectOut\n\nrouter = APIRouter()\n\n@router.get('/object/{object_id}')\nasync def get_object(\n    object_id: UUID, \n    db: Session = Depends(get_sync_db(\"the_other_db_client\"))\n):\n    return ObjectOut(\n        **db.query(ObjectOrm).filter(ObjectOrm.id==object_id).one()\n    )\n</code></pre>"},{"location":"user-guide/setup/","title":"Setup","text":"<p>Bingqilin exposes a <code>setup_utils()</code> function that takes a <code>ConfigModel</code> settings instance and your FastAPI app instance to add any configured features.</p> <pre><code>from bingqilin import setup_utils\n\nfrom .settings import settings\n\napp = FastAPI()\nsetup_utils(app, settings.data)\n</code></pre> <p>You can pass in keyword arguments that override the values from your settings data, or you can forgo the <code>setup_utils()</code> function call completely and enable whatever utilities you'd like.</p> <p><code>setup_utils()</code> does the following things:</p> <ul> <li>Adds an exception handler to log validation errors</li> <li>Adds the route operation to handle reconfigures</li> <li>Adds the <code>ConfigModel</code> instance to the OpenAPI spec</li> </ul> <p>In the example above, <code>settings</code> is an instance of <code>bingqilin.conf:SettingsManager</code>, which you can learn more about here.</p>"}]}